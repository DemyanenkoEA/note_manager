from datetime import date

"""
add_titles_loop.py: Цикл для добавления заголовков

Функциональность:
Запрашивает у пользователя заголовки.
Позволяет завершить ввод специальной командой или пустым вводом.
Выводит итоговый список добавленных заголовков.
"""
# Объявляем список для хранения заголовков заметки
titles = list()
while True:
    title = input("Введите заголовок (напишите слово 'стоп' или оставьте пустым для завершения ввода заголовков): ")
    if title in ['', 'стоп']:
        break
    else:
        if title in titles:
            print("Такой заголовок уже существует в списке заголовков!")
            continue
        titles.append(title)
if not titles:
    print("Список заголовков заметки пуст!")
else:
    print('Заголовки заметки: ')
    for value in titles:
        print(' - ', value)

"""
update_status.py: Проверка и обновление статуса заметки

Функциональность:
Показывает текущий статус заметки.
Предлагает изменить статус на один из предложенных.
Обрабатывает некорректный ввод.
"""
# Объявляем словарь с вариантами статусов заметок,
# каждому варианту статус указываем свою цифру
note_statuses = {1: 'Выполнено', 2: 'В процессе', 3: 'Отложено'}
# Объявляем словарь с данными заметки
# Указывая элементу 'status' словаря 'note' значение,
# создаем его и указываем что статус равен "В процессе"
note = {"status": note_statuses[2]}
# Запуска цикл, с выводом текущего статуса заметки, и вопрос об изменения текущего статуса
while True:
    # Выводим текущий статус заметки который ранее указали.
    # Вывод осуществляется указанием индекса в словаре вариантов статуса заметки
    print("Текущий статус заметки: ", note['status'])
    # Выводим текст с предложением об изменение статуса
    change_status = input("Изменить текущий статус заметки (Да/1 или Нет/0):").lower()
    # Делаем проверку ввода пользователя
    # Если пользователь ввел Да или 1
    if change_status in ['да', '1']:
        # Создаем новый цикл ввода нового статуса и его проверки
        while True:
            # Выводим меню
            print("Выберите новый статус заметки:")
            print("\t1. Выполнено")
            print("\t2. В процессе")
            print("\t3. Отложено")
            # Просим произвести выбор варианта
            # Введенные данные сразу преобразовываем в int
            try:
                variant = int(input("\nВаш вариант: "))
            except ValueError:
                input('ОШИБКА: Вы указали неправильный вариант статуса заметки!\nДля повтора нажмите Enter')
                continue
            # Проверяем если выбранный вариант у нас в списке ключей словаря с вариантами статуса
            # Если есть вариант в ключах
            if variant in note_statuses.keys():
                print('Вы указали новый статус заметки: ', note_statuses[variant])
                note['status'] = note_statuses[variant]
                break
            # Если ключа нет либо неправильный ввод
            else:
                input('ОШИБКА: Вы указали неправильный вариант статуса заметки!\n Для повтора нажмите > Enter')

    # Если пользователь ввел "нет" или 0
    elif change_status in ['нет', '0']:
        print('Вы решили оставить статус заметки неизмененным')
    # Если пользователь указал иной вариант ввода кроме Да/1 и Нет/0
    else:
        print('Вы ввели неправильные данные')

"""
check_deadline.py: Обработка дедлайнов
 Функциональность:
Запрашивает дату дедлайна и сравнивает её с текущей
датой.
Сообщает, истёк ли дедлайн или сколько дней осталось.
Проверяет корректность формата ввода.
"""


def print_current_date():
    # Вызываем функцию now(), получаем строку, и форматируем ее в необходимый вид
    cur_date = datetime.now().strftime("%d-%m-%Y")
    # Второй вариант решения данной задачи
    # now = datetime.now()
    # cur_date = "{}-{}-{}".format(now.day, now.month, now.year)
    print("Текущая дата:", cur_date)


# Функция определения текущей даты, и возвращение форматированной строки с текущей датой
def get_current_date():
    # Вызываем функцию now(), получаем строку, и форматируем ее в необходимый вид
    current_date = datetime.now().strftime("%d-%m-%Y")
    # Возвращаем текущую дату
    return current_date


# Функция запроса ввода даты дедлайна заметки, проверки правильности ввода даты
def enter_issue_date():
    # Создаем вечный цикл на проверку ввода правильной даты
    while True:
        # Запрашиваем ввода даты дедлайна
        temp_issue_date = input("Введите дату истечения заметки в формате 'день-месяц-год': ")
        # С помощью блока try/except осуществляем корректность введенной
        try:
            # С помощью функции strptime() проверяем введенную дату на необходимый формат
            valid_date = datetime.strptime(temp_issue_date, '%d-%m-%Y')
            # Проверка даты на значение раньше чем сегодня
            # if valid_date <= datetime.now():
            # print("Дата истечения срока заметки не может быть раньше даты создания заметки")
            # continue
            # В случае корректного вода возвращаем стройку с датой из функции
            return valid_date.date()
        # В случае ошибки выводим сообщение и возвращаемся к началу цикла
        except ValueError:
            print('Вы указали дату в неправильной формате! Просим повторить ввод в таком формате "день-месяц-год"')


# Функция проверки переданной ей даты дедлайна с текущей датой, и возвратом разницы дней
# Параметр дата в виде переменной типа date()
def check_issue_date(issue_date):
    # Берем значение текущей даты и вычитаем от переданной даты дедлайна.
    # Получаем разницу количества дней, и далее на основе разницы выводим информацию
    difference_days = issue_date - date.today()
    # Если разница дней равна 0,
    if difference_days.days == 0:
        print("Дедлайн сегодня!")
    # Если разница дней равна 1, то дедлайн истекает завтра
    elif difference_days.days == 1:
        print("Дедлайн истекает завтра!")
    # Если разница дней равна -1, то дедлайн уже истек вчера
    elif difference_days.days == -1:
        print("Внимание! Дедлайн истек вчера!")
    # Если разница дней больше 1, то дедлайн истекает через n дней
    elif difference_days.days > 1:
        # Производим делением с остатком количества дней на 10, чтобы решить какое слово вставлять в предложение
        var = difference_days.days % 10
        # Если количество дней равно 2,3,4... 22,23,24,
        if 2 <= var <= 4:
            word = "дня!"
        else:
            word = "дней!"
        print("До дедлайна осталось ", difference_days.days, word)
    # Если разница дней равна меньше -1, то дедлайн уже истек n количества дней
    elif difference_days.days < -1:
        var = difference_days.days % 10
        if 2 <= var <= 4:
            word = "дня"
        else:
            word = "дней"
        print("Внимание! Дедлайн истёк", abs(difference_days.days), word, "назад!")


# ----------------------------------------------------------------------------------------
# Объявляем слова заметок
note = {'issue_date': datetime.now()}
# Присваиваем элементу issue_date, текущую дату в формате datetime
# Цикл для проверки работоспособности функций
print_current_date()
while True:
    # Вывод текущей даты
    note["issue_date"] = enter_issue_date()
    check_issue_date(note['issue_date'])
    input("Для продолжения проверки нажмите Enter")

"""
multiple_notes.py: Работа с несколькими заметками

Функциональность:
Создаёт несколько заметок через ввод данных (имя, заголовок, описание, статус, дату создания, дедлайн).
Хранит заметки в списке словарей.
Выводит список всех заметок.
"""
# Функция ввода заголовков заметки и возврат ее результатом функции
def enter_note_titles():
    # Объявляем список для хранения заголовков заметки
    titles = list()
    while True:
        title = input("Введите заголовок (напишите слово 'стоп' или оставьте пустым для завершения ввода заголовков): ")
        if title in ['', 'стоп']:
            break
        else:
            if title in titles:
                print("Такой заголовок уже существует в списке заголовков!")
                continue
            titles.append(title)
    return titles


# Функция ввода статуса заметки и возврат ее результатом функции
def enter_note_status():
    # Объявляем словарь с вариантами статусов заметок,
    # каждому варианту статус указываем свою цифру
    note_statuses = {1: 'Выполнено', 2: 'В процессе', 3: 'Отложено'}
    # Запуска цикл, с выводом текущего статуса заметки, и вопрос об изменения текущего статуса
    while True:
        # Выводим меню выбора статуса заметки
        print("Выберите статус заметки:")
        print("\t1. Выполнено")
        print("\t2. В процессе")
        print("\t3. Отложено")
        # Просим произвести выбор варианта
        # Введенные данные сразу преобразовываем в int
        try:
            variant = int(input("\nВаш вариант: "))
        except ValueError:
            input('ОШИБКА: Вы указали неправильный вариант статуса заметки!\nДля повтора нажмите Enter')
            continue
        # Проверяем если выбранный вариант у нас в списке ключей словаря с вариантами статуса
        # Если есть вариант в ключах
        if variant in note_statuses.keys():
            return variant
        # Если ключа нет либо неправильный ввод
        else:
            input('ОШИБКА: Вы указали неправильный вариант статуса заметки!\nДля повтора нажмите Enter')


# Функция ввода даты создания заметки и возврат ее результатом функции
def enter_created_date():
    # Создаем вечный цикл на проверку ввода правильной даты
    while True:
        # Дата создания заметки в формате "день-месяц-год", например "10-11-2024"
        temp_created_date = input("Введите дату создания заметки в формате 'день-месяц-год': ")
        try:
            # Функцией strptime проверяем корректность ввода
            temp_created_date = datetime.strptime(temp_created_date, '%d-%m-%Y')
            # Возвращаем объект datetime
            return temp_created_date
        except ValueError:
            print('Вы указали дату в неправильной формате! Просим повторить ввод в таком формате "день-месяц-год"')


# Функция ввода даты когда заметка истекает (дедлайн) и возврат ее результатом функции
def enter_issue_date():
    # Создаем вечный цикл на проверку ввода правильной даты
    while True:
        # Дата истечения заметки (дедлайн) в формате "день-месяц-год", например "10-12-2024"
        temp_issue_date = input("Введите дату истечения заметки в формате 'день-месяц-год': ")
        try:
            temp_issue_date = datetime.strptime(temp_issue_date, '%d-%m-%Y')
            # Возвращаем объект datetime
            return temp_issue_date
        except ValueError:
            print('Вы указали дату в неправильной формате! Просим повторить ввод в таком формате "день-месяц-год"')


# Функция вывода содержимого заметок
def print_notes(notes_list):
    if not notes_list:
        print("Список заметок пуст!")
        return
    print("\nСписок заметок:")
    print('-' * 100)
    for note_ in notes_list:
        print('Имя пользователя:', note_['username'])
        if len(note_['titles']) == 1:
            print('Заголовок:', note_['titles'][0])
        else:
            print('Заголовки:')
            for title in note_['titles']:
                print('\t-', title)
        print('Описание:', note_['content'])
        print('Статус:', note_['status'])
        # ВЫВОДИМ ДАТЫ СОЗДАНИЯ И ДЕДЛАЙНА В СОКРАЩЕННОМ ВИДЕ СОГЛАСНО РАНЕМУ ТЗ
        # print('Дата создания:',datetime.strptime(note_['created_date'], "%Y-%m-%d").strftime("%d-%m"))
        print('Дата создания:', datetime.date(note_['created_date']).strftime("%d-%m"))
        # print('Дедлайн:', datetime.strptime(note_['issue_date'], "%Y-%m-%d").strftime("%d-%m"))
        print('Дедлайн:', datetime.date(note_['issue_date']).strftime("%d-%m"))
        print('-' * 100)


# Функция получения максимального значения note_id словаря заметки в списке заметок
def get_max_note_id(notes_list):
    # Присваиваем переменной значение 0
    # С помощью функции max() ищем максимальное значение в сгенерированном списке из списка заметок
    max_value = max([n['note_id'] for n in notes_list])
    # Возвращаем значение
    return max_value


# Создаем список с заведомо указанными данными заметок
notes = [
    {'username': 'Алексей', 'titles': ['Заголовок1'], 'content': 'Контент1', 'status': 'В процессе',
     'created_date': datetime(2024, 12, 10), 'issue_date': datetime(2024, 12, 10), 'note_id': 1},
    {'username': 'Антон', 'titles': ['Заголовок2', 'Заголовок21', 'Заголовок22', 'Заголовок23'], 'content': 'Контент2',
     'status': 2, 'created_date': datetime(2024, 12, 10), 'issue_date': datetime(2024, 12, 10), 'note_id': 2},
    {'username': 'Петр', 'titles': ['Заголовок3', 'Заголовок31'], 'content': 'Контент3', 'status': 'В процессе',
     'created_date': datetime(2024, 12, 10), 'issue_date': datetime(2024, 12, 10), 'note_id': 3},
    {'username': 'Петр', 'titles': ['Заголовок4', 'Заголовок41'], 'content': 'Контент4', 'status': 'В процессе',
     'created_date': datetime(2024, 12, 10), 'issue_date': datetime(2024, 12, 10), 'note_id': 4},
    {'username': 'Алексей', 'titles': ['Список покупок'], 'content': 'Купить продукты на неделю',
     'status': 'В процессе',
     'created_date': datetime(2024, 12, 10), 'issue_date': datetime(2024, 12, 10), 'note_id': 5},
    {'username': 'Мария', 'titles': ['Учеба'], 'content': 'Подготовиться к экзамену', 'status': 'В процессе',
     'created_date': datetime(2024, 12, 10), 'issue_date': datetime(2024, 12, 10), 'note_id': 6}
]

# Создание пустого списка для отладки
# notes = []

print('Добро пожаловать в менеджер заметок! Вы можете добавить новую заметку.')
while True:
    # Объявляем словарь для хранения информации о заметке
    note = dict()
    # Находим максимальное значение note_id и увеличиваем на 1 для получения уникального ID
    note["note_id"] = get_max_note_id(notes) + 1
    # Объявляем переменные и запрашиваем информацию у пользователя
    # Имя пользователя
    note["username"] = input("Введите имя пользователя: ")
    # Добавляем в словарь заметки заголовки, вызвавши функцию ввода заметок
    note["titles"] = enter_note_titles()
    # Описание заметки
    note["content"] = input("Введите описание заметки: ")
    # Присвоение статуса заметки, вызовом функции ввода статуса заметки
    note['status'] = enter_note_status()
    # Присвоение даты создания заметки, вызовом функцией ввода даты создания
    note["created_date"] = enter_created_date()
    # Присвоение даты когда истекает заметка, вызовом функции ввода даты истекания заметки
    note["issue_date"] = enter_issue_date()
    # Добавляем заметку в список заметок
    notes.append(note)
    while True:
        # Выводим текст с предложением о еще одной заметке
        result = input("Хотите добавить ещё одну заметку? (да/нет,стоп):").lower()
        # Делаем проверку ввода пользователя
        # Если пользователь ввел "нет", то выводим список заметок
        if result in ['нет', 'стоп']:
            print_notes(notes)
        # Если пользователь ввел "да", то начинаем добавлять новую заметку
        elif result in ['да']:
            break

"""
Удаление заметок

Функциональность:
Удаляет заметку по имени пользователя или заголовку.
Выводит сообщение, если заметка не найдена.
Обновляет список заметок.
"""
from datetime import datetime

# Создаем список, с вложенными словарями хранящие данные о заметках
notes = [
    {'username': 'Алексей', 'titles': ['Заголовок1'], 'content': 'Контент1', 'status': 2,
     'created_date': datetime(2024, 12, 10), 'issue_date': datetime(2024, 12, 10), 'note_id': 1},
    {'username': 'Антон', 'titles': ['Заголовок2', 'Заголовок21', 'Заголовок22', 'Заголовок23'], 'content': 'Контент2',
     'status': 2, 'created_date': datetime(2024, 12, 10), 'issue_date': datetime(2024, 12, 10), 'note_id': 2},
    {'username': 'Петр', 'titles': ['Заголовок3', 'Заголовок31'], 'content': 'Контент3', 'status': 2,
     'created_date': datetime(2024, 12, 10), 'issue_date': datetime(2024, 12, 10), 'note_id': 3},
    {'username': 'Петр', 'titles': ['Заголовок4', 'Заголовок41'], 'content': 'Контент4', 'status': 1,
     'created_date': datetime(2024, 12, 10), 'issue_date': datetime(2024, 12, 10), 'note_id': 4},
    {'username': 'Алексей', 'titles': ['Список покупок'], 'content': 'Купить продукты на неделю', 'status': 1,
     'created_date': datetime(2024, 12, 10), 'issue_date': datetime(2024, 12, 10), 'note_id': 5},
    {'username': 'Мария', 'titles': ['Учеба'], 'content': 'Подготовиться к экзамену', 'status': 1,
     'created_date': datetime(2024, 12, 10), 'issue_date': datetime(2024, 12, 10), 'note_id': 6}
]


# Для отладки
# notes = list()

# Функция вывода содержимого заметок
def print_notes(notes_list):
    if not notes_list:
        print("Список заметок пуст!")
        return
    print("\nСписок заметок:")
    print('-' * 100)
    for note_ in notes_list:
        print('Имя пользователя:', note_['username'])
        if len(note_['titles']) == 1:
            print('Заголовок:', note_['titles'][0])
        else:
            print('Заголовки:')
            for title_ in note_['titles']:
                print('\t-', title_)
        print('Описание:', note_['content'])
        print('Статус:', note_['status'])
        # ВЫВОДИМ ДАТЫ СОЗДАНИЯ И ДЕДЛАЙНА В СОКРАЩЕННОМ ВИДЕ СОГЛАСНО РАНЕМУ ТЗ
        # print('Дата создания:',datetime.strptime(note_['created_date'], "%Y-%m-%d").strftime("%d-%m"))
        print('Дата создания:', datetime.date(note_['created_date']).strftime("%d-%m"))
        # print('Дедлайн:', datetime.strptime(note_['issue_date'], "%Y-%m-%d").strftime("%d-%m"))
        print('Дедлайн:', datetime.date(note_['issue_date']).strftime("%d-%m"))
        print('-' * 100)


def print_note(note_):
    print('-' * 100)
    # print("Информация о заметке:")
    print('Имя пользователя:', note_['username'])
    if len(note_['titles']) == 1:
        print('Заголовок:', note_['titles'][0])
    else:
        print('Заголовки:')
        for title_ in note_['titles']:
            print('\t-', title_)
    print('Описание:', note_['content'])
    print('Статус:', note_['status'])
    # ВЫВОДИМ ДАТЫ СОЗДАНИЯ И ДЕДЛАЙНА В СОКРАЩЕННОМ ВИДЕ СОГЛАСНО РАНЕМУ ТЗ
    # print('Дата создания:',datetime.strptime(note_['created_date'], "%Y-%m-%d").strftime("%d-%m"))
    print('Дата создания:', datetime.date(note_['created_date']).strftime("%d-%m"))
    # print('Дедлайн:', datetime.strptime(note_['issue_date'], "%Y-%m-%d").strftime("%d-%m"))
    print('Дедлайн:', datetime.date(note_['issue_date']).strftime("%d-%m"))
    print('-' * 100)


# Функция вывода информации о заметке


# Функция удаления заметки из списка заметок по имени пользователя или заголовку
def delete_note(notes_list):
    if not notes_list:
        print("Список заметок пуст!")
        return
    # Запускаем цикл ввода критерия поиска
    while True:
        # Запрашиваем ввод критерия поиска.
        # Преобразовываем строку в нижний регистр
        search_str = input("Введите имя пользователя или заголовок для удаления заметки:").lower()
        # Проверка если пользователь ввел пустую строку
        if not search_str:
            # Пустая строка критерия, выводим предупреждение
            print("Вы не указали критерий для удаления!")
            # Выходим из функции
            # return
            # Или повторяем ввода критерия
            continue
        # Если строка критерия поиска не пустая, выходим из цикла ввода критерия
        else:
            break
    # Переменная флаг указывающая что заметка(и) были найдены
    founded = False
    # Список для хранения заметок, которые мы нашли согласно критерия и необходимо удалить
    # Так как попался баг, после удаления элемента напрямую из списка во время цикла, пропускается одна строка из
    # смены индексов. В смысле если идут две строки на удаление, то одна удаляется, а следующая пропускается
    need_delete = list()
    # Цикл прохождения по списку заметок
    for note_ in notes_list:
        # Проверяем существует ли критерий поиска в элементе словаря заметки, а также
        # проверяем критерий поиска в списке заголовков, которые тоже преобразовываем в список с нижним регистром
        if search_str in note_['username'].lower() or search_str in [x.lower() for x in note_['titles']]:
            founded = True
            print("Найдена следующая заметка:")
            print_note(note_)
            # Цикл выполнения запроса на удаление
            while True:
                # Запрашиваем строку, преобразовываем строку в нижний регистр
                question = input("Вы уверены, что хотите удалить заметку? (да/нет):").lower()
                # Если пользователь указал "да"
                if question == 'да':
                    # Удаляем заметку из списка словарей заметок занося ее в список на удаление
                    # notes_list.remove(note) - тут вылезет баг
                    need_delete.append(note_)
                    # Выводим сообщение об успешном удалении заметки
                    print("Заметка успешно удаленна!")
                # Если пользователь указал "нет"
                elif question == 'нет':
                    # Выводим сообщение о том что заметка не удалена
                    print('Заметка не удаленна!')
                # Если пользователь ввел иное, то повторяем цикл сначала
                else:
                    continue
                # После правильного данного ответа да/нет, выходим из цикла
                break
    # Если есть что удалять, то удаляем по циклу
    if need_delete:
        for n in need_delete:
            notes.remove(n)
    need_delete.clear()
    if not founded:
        print("Заметок с таким именем пользователя или заголовком не найдено!")


# Цикл для проверки работоспособности кода
while True:
    # Выводим список заметок
    print_notes(notes)
    # Удаляем из списка заметки которые не нужны
    delete_note(notes)
    input("Для продолжения нажмите Enter...")
